<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link href="/f/Nunito.css" rel="stylesheet">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Blog Atom feed" />
<link rel="stylesheet" type="text/css" href="/post.css" >
<title>RiiR: Ghosts of Departed Proofs</title>
</head>
<body>
<div>
<header>
	<created>2020 Jan 15</created>
	<ptitle><h1>&gt;&nbsp;RiiR: Ghosts of Departed Proofs</h1></ptitle>
</header>
<p>This is the first in hopefully a series of posts where I try rewriting something in <a href="https://www.rust-lang.org/">Rust</a>.</p>
<h2>The inspiration</h2>
<p>Read an interesting paper called <a href="https://kataskeue.com/gdp.pdf">Ghosts of Departed Proofs</a> about using the type
system in haskell to ensure certain properties are met when using a library,
without using any extra computation or space at runtime.</p>
<p>The example given is to make sure that users of a merging and sorting library
don't mess up the calls into the library.
When they call
x = sort_by(comp, list1)
y = sort_by(comp, list2)
z = merge_by(comp, x, y)</p>
<p><code>comp</code> here is some comparison function that must be the same. Thus
x = sort_by(comp, list1)
y = sort_by(other_comp, list2)
z = merge_by(comp, x, y)</p>
<p>will be undefined, though the likely result is that <code>z</code> is not sorted.</p>
<p>The paper proposes a way of naming the <code>comp</code> function, but we only want that &quot;name&quot;
to exist at compile-time, and to not affect runtime at all.</p>
<p>Haskell has a concept of <a href="https://wiki.haskell.org/Phantom_type">&quot;phantom types&quot;</a> which are types that
end up with no runtime representation, which this paper uses, along with GHC haskell's
<a href="https://wiki.haskell.org/GHC/Coercible"><code>Coercible</code></a>, to generate unique types for every &quot;name&quot;, so that attempts to use
one named object in place of another will result in a compiler error.
Since the &quot;name&quot; is a phantom type variable, it will result in no runtime overhead.</p>
<h2>The result</h2>
<p>I decided to try implementing <a href="https://kataskeue.com/gdp.pdf">GDP</a> in <a href="https://www.rust-lang.org/">Rust</a>.
First thing we need is a way of attaching types to other types without attaching data.
Rust has [`PhantomData] for that, which is similar enough for my use.</p>
<p>One of the issues I ran into early on, was trying to just rewrite the functions from the paper</p>
<pre><code>struct Named&lt;Name, A&gt;(A, PhantomData&lt;Name&gt;);
fn named&lt;Name, A, T, K: Fn(Named&lt;A, Name&gt;) -&gt; T&gt;(x: A, k: K) -&gt; T {
	k(Named(x, PhantomData))
}
</code></pre>
<p>resulted in the compiler not knowing what type to give <code>Name</code>, and it wanted <em>me</em> to specify.
Well I don't know what type to give it.
Thinking about it, I reworded the issue as: I need a unique type to be created for every call to name.</p>
<h3>You're going to make <em>me</em> do this?</h3>
<p>After wording it this way, I remembered something I'd read and run into when trying to use closures in Rust.</p>
<pre><code>fn run_fn(f: Fn(i64) -&gt; i64, x: i64) -&gt; i64 {
	f(x)
}

fn main() {
	run_fn(|x| x*2, 2)
}
</code></pre>
<p>will get compiler errors,</p>
<pre><code>warning: trait objects without an explicit `dyn` are deprecated
 --&gt; src/main.rs:1:14
  |
1 | fn run_it(f: Fn(i64) -&gt; i64, x: i64) -&gt; i64 {
  |              ^^^^^^^^^^^^^^ help: use `dyn`: `dyn Fn(i64) -&gt; i64`
  |
  = note: `#[warn(bare_trait_objects)]` on by default

error[E0277]: the size for values of type `(dyn std::ops::Fn(i64) -&gt; i64 + 'static)` cannot be known at compilation time
 --&gt; src/main.rs:1:11
  |
1 | fn run_it(f: Fn(i64) -&gt; i64, x: i64) -&gt; i64 {
  |           ^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn(i64) -&gt; i64 + 'static)`
  = note: to learn more, visit &lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
  = note: all local variables must have a statically known size
  = help: unsized locals are gated as an unstable feature

error[E0308]: mismatched types
 --&gt; src/main.rs:6:12
  |
6 |     run_it(|x| x*2, 2)
  |            ^^^^^^^ expected trait std::ops::Fn, found closure
  |
  = note: expected type `(dyn std::ops::Fn(i64) -&gt; i64 + 'static)`
             found type `[closure@src/main.rs:6:12: 6:19]`
</code></pre>
<ol>
<li>
<p><code>Fn(i64) -&gt; i64</code> is a <em>trait</em> not a type, so old behaviour is for the compiler to look at that and say &quot;f will be an object with <em>some type that implements Fn...</em>&quot;
if I want that, I should specify by adding <code>dyn</code> before the trait</p>
</li>
<li>
<p>even with the <code>dyn</code> behaviour, it complains that the type is not known statically at compile time.
You need this in rust, because the way the compiler is working for pass-by-value
add f to stack
add x to stack
call run_it</p>
<p>if the compiler doesn't know how big <code>f</code> is going to be, it can't make the <code>add f to stack</code> commands</p>
<p>Usually, for <code>dyn</code> arguments, you want to pass-by-reference, so either <code>&amp;dyn Fn(_) -&gt; _</code> or <code>Box&lt;dyn Fn(_) -&gt; _&gt;</code></p>
</li>
<li>
<p>there is an alternative to <code>dyn</code> which is <code>impl</code> types, and writing
fn run_it(f: impl Fn(i64) -&gt; i64, x: i64) -&gt; i64</p>
<p>is like writing
fn run_it&lt;F: Fn(i64) -&gt; i64&gt;(f: F, x: i64) -&gt; i64</p>
<p>This is known as &quot;static dispatch&quot; and the result is similar to C++ templates.
It is also saying &quot;<code>f</code> is of <em>some type that implements Fn...</em>&quot;, but instead of telling the compiler
to add type information alongside the data at runtime (like <code>dyn</code>), it tells the compiler to create
a version of <code>run_it</code> for every type that is passed in for <code>f</code> in this program.</p>
</li>
</ol>
<p>lastly, that line</p>
<pre><code>  = note: expected type `(dyn std::ops::Fn(i64) -&gt; i64 + 'static)`
             found type `[closure@src/main.rs:6:12: 6:19]`
</code></pre>
<p>is what interests me.
<code>[closure@src/main.rs:6:12: 6:19]</code> is not a type that I can specify in source, that is generated by the compiler.
In rust, no matter how similar two closures are, if they are defined in two separate lines of source, they get two unique and non-overlapping types.</p>
<p>To demonstrate this, we can look at return types.
A function must only return <em>one</em> type, so</p>
<pre><code>fn no_bueno(b: bool) -&gt; impl F {
	if b {
		||{}
	} else {
		||{}
	}
}
</code></pre>
<p>results in</p>
<pre><code>error[E0308]: if and else have incompatible types
 --&gt; src/lib.rs:5:9
  |
2 | /     if b {
3 | |         ||{}
  | |         ---- expected because of this
4 | |     } else {
5 | |         ||{}
  | |         ^^^^ expected closure, found a different closure
6 | |     }
  | |_____- if and else have incompatible types
  |
  = note: expected type `[closure@src/lib.rs:3:9: 3:13]`
             found type `[closure@src/lib.rs:5:9: 5:13]`
  = note: no two closures, even if identical, have the same type
  = help: consider boxing your closure and/or using it as a trait object
</code></pre>
<p>I can use closure types as my type for <code>Name</code> in the <code>named</code> function, then
the compiler will generate a unique type for me at compile time.</p>
<h3>Complete example</h3>
<pre><code>mod named {
    use core::marker::PhantomData;

    #[derive(Clone)]
    pub struct Named&lt;Name, A&gt;(pub A, PhantomData&lt;Name&gt;);

    // don't use this, use the macro name!
    pub fn name&lt;Name: Fn(), T, A, K: Fn(Named&lt;Name, A&gt;) -&gt; T&gt;(_: Name, x: A, k: K) -&gt; T {
        k(Named(x, PhantomData))
    }
    
    #[macro_export]
    macro_rules! name {
        ($x:expr, $k:expr) =&gt; {
            // (ab)using rustc's implementation of closure types
            // the compiler generates a unique type for every closure
            // thus if we pass a new closure every time, then Name is given a unique type every time as well
            // here &quot;||{}&quot; is a closure that takes no arguments and does nothing
            $crate::named::name(||{}, $x, $k)
        }
    }
}

mod listutils {
    use core::cmp::Ordering;
    pub fn merge_by&lt;A, Comp: Fn(&amp;A, &amp;A) -&gt; Ordering&gt;(comp: Comp, mut xs: Vec&lt;A&gt;, mut ys: Vec&lt;A&gt;) -&gt; Vec&lt;A&gt; {
        if xs.is_empty() { return ys; }
        if ys.is_empty() { return xs; }
        match comp(&amp;xs[xs.len() - 1], &amp;ys[ys.len() - 1]) {
            Ordering::Greater =&gt; {
                let x = xs.pop().unwrap();
                let mut ret = merge_by(comp, xs, ys);
                ret.push(x);
                ret
            },
            _ =&gt; {
                let y = ys.pop().unwrap();
                let mut ret = merge_by(comp, xs, ys);
                ret.push(y);
                ret
            }
        }
    }
    
    pub fn greater_than&lt;A: Ord&gt;(x: &amp;A, y: &amp;A) -&gt; Ordering {
        x.cmp(y)
    }
}

mod sorted {
    use super::named::Named;
    use super::listutils as U;
    use core::marker::PhantomData;
    use core::cmp::Ordering;
    
    #[derive(Clone)]
    pub struct SortedBy&lt;Comp, A&gt;(pub A, PhantomData&lt;Comp&gt;);
    
    pub fn sort_by&lt;Comp, A, CompFn: Fn(&amp;A, &amp;A) -&gt; Ordering&gt;(comp: Named&lt;Comp, CompFn&gt;, mut xs: Vec&lt;A&gt;) -&gt; SortedBy&lt;Comp, Vec&lt;A&gt;&gt; {
        SortedBy({ xs.sort_unstable_by(comp.0); xs }, PhantomData)
    }
    
    pub fn merge_by&lt;Comp, A, CompFn: Fn(&amp;A, &amp;A) -&gt; Ordering&gt;(comp: Named&lt;Comp, CompFn&gt;, xs: SortedBy&lt;Comp, Vec&lt;A&gt;&gt;, ys: SortedBy&lt;Comp, Vec&lt;A&gt;&gt;) -&gt; SortedBy&lt;Comp, Vec&lt;A&gt;&gt; {
        SortedBy(U::merge_by(comp.0, xs.0, ys.0), PhantomData)
    }
}

use sorted::*;
use listutils::greater_than;

fn main() {
    name!(greater_than, |gt| {
        let xs = sort_by(gt.clone(), vec![6, 2, 4]);
        let ys = sort_by(gt.clone(), vec![5, 1, 4]);
        println!(&quot;{:?}&quot;, merge_by(gt, xs, ys).0);
    });
    
    fn less_than&lt;A: Ord&gt;(x: &amp;A, y: &amp;A) -&gt; core::cmp::Ordering { greater_than(x, y).reverse() }
    name!(greater_than, |up| {
        name!(less_than, |down| {
            let xs = sort_by(up.clone(), vec![6, 2, 4]);
            let ys = sort_by(down.clone(), vec![5, 1, 4]);
            // this will not compile
            // println!(&quot;{:?}&quot;, merge_by(up, xs, ys).0);
        })
    });
}
</code></pre>
<p>also see it <a href="0115/gdp.rs">here</a></p>
<h3>Conclusion</h3>
<p>This implementation has to use a macro and a closure to mimic the usage of <code>coerce</code> and rank-2 types in haskell, but the end result is pretty similar.</p>
<p>There's a chance that this actually <em>does</em> result in some overhead in the executable,
because multiple instances of <code>name</code> might be created for each <code>Name</code> type,
but maybe that can be improved (without losing the gdp stuff) by using <code>dyn</code> types?</p>
<p>I've also thought about using rust lifetimes instead of <code>PhantomData</code> types but I haven't figured out a way to
get the compiler to create unique, non-intersecting lifetimes.</p>
<p><strong>-JD</strong></p>
</div>
</body>
</html>
