<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link href="/f/Nunito.css" rel="stylesheet">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Blog Atom feed" />
<script type="application/ld+json">
{ "@context": "http://schema.org"
, "@type": "BlogPosting"
, "headline": "Parsing 1: PDA"
, "author": {"@type": "Person", "name": "Joshua Lloret"}
, "datePublished": "2019-11-09"
, "dateModified": "2019-11-29"
}
</script>
<link rel="stylesheet" type="text/css" href="/post.css" >
<title>Parsing 1: PDA</title>
</head>
<body>
<div>
<header>
	<created>2019 Dec 9<br/><i>updated: 2019 Dec 29</i></created>
	<ptitle><h1>&gt;&nbsp;Parsing 1: PDA</h1></ptitle>
</header>
<p>I go back and forth reading/doing and now I'm trying to add teaching to the loop.
While I can't say if this will be usable by anyone but myself, it's some really informal blog posting on my thoughts for making a parser.</p>
<p>I like coding in C, because it makes me think about Data+Algorithms, and that's a different mindset than when I'm thinking in Type Theory.
So I tried giving some of this as an informal talk to some coworkers a couple weeks back.
It was nominally an introduction to yacc, but I think this will be a series of blog posts describing me trying to get some hands on understanding of different ways to build a parser.</p>
<p>This first post is both very hand-wavy and very nitty-gritty, so buckle up.
I'll be referencing C code throughout the post, but you can find the full file <a href="1109-parser1_PDA/parser.c">parser.c</a>.</p>
<h2>The Language</h2>
<p>First, let's look at a langauge that has some really simple stuff I want to be able to parse.</p>
<pre><code>(t|f)&amp;t
</code></pre>
<p>Usually the starter language for parsing is some numeric calculator like dc, simple arithmetic.
This is even simpler, and my endgoal is quantum circuits, so logical arithmetic is a nice start.</p>
<p>The language is defined by the following BNF grammar</p>
<pre><code>expr ::=
	| 't'
	| 'f'
	| '(' expr ')'
	| '!' expr
	| expr '&amp;' expr
	| expr '|' expr
	;
</code></pre>
<p>One nice feature of this is that it's a recursive grammar.
Simply stated above, it's a <em>left</em> recursive grammar, which will turn out to be really annoying in some future steps.</p>
<h2>Finite State Machine</h2>
<p>We can parse this with two states: expecting chars that start an expression, and expecting chars that can come after an expression.
Let's call these states respectively: <code>S</code> and <code>E</code>.</p>
<pre><code>  S E
t E
f E
( S
)   E
! S
&amp;   S
|   S
</code></pre>
<p>The table is meant to be read to find the next state given a current state and an input.
So &quot;I'm in state <code>E</code> and I read in an '&amp;', then the next state is <code>S</code>&quot;.
If there's no entry in the table, then that indicates a parsing error.</p>
<p>Here's an implementation in C of that state machine, hopefully you can see the switches correspond to first checking the column in the table, then checking the row.</p>
<pre><code>typedef enum State { S_S, S_E } State;

int
parse() {
	State s;
	int c;

	while((c=getchar(stdin)) != EOF &amp;&amp;  c != '\n')
	switch (s) {
	case S_S: switch (c) {
		case 't': s = S_E; break;
		case 'f': s = S_E; break;
		case '!': s = S_S; break;
		case '(': s = S_S; break;
		default: err(&quot;Unexpected&quot;);
		} break;

	case S_E: switch (c) {
		case '&amp;': s = S_S; break;
		case '|': s = S_S; break;
		case ')': s = S_E; break;
		default: err(&quot;Unexpected&quot;);
		} break;
	}

	return s == E;
}
</code></pre>
<p>The nice thing is parsing is never ambiguous, that is, it's always clear given the current state and input what the next state should be.
The table above doesn't <em>actually</em> represent an acceptor for our grammar though.
It recognizes &quot;t &amp; f&quot; sure, but it recognizes too much.
For instance, it thinks &quot;))))&quot; is a valid input.</p>
<p>Since our grammar includes nesting parentheses, we'll need to keep track of that.
Could just introduce a counter, that increases for '(' and decreases for ')'.
Check that it never goes negative, and that we're back at 0 at the end, and we should be good.</p>
<pre><code>int pars = 0;
...
	case '(': ... ; pars++; break;
...
	case ')': ... ; if (pars == 0) err(&quot;Unexpected&quot;); pars--; break;
...
if (pars != 0) err(&quot;Expected more&quot;);
return s == S_E;
</code></pre>
<p>Cool, that oughta work as an acceptor.</p>
<p>What happens if we want to actually evaluate it though?</p>
<h2>Evaluating</h2>
<p>To think like a human for a second: for expressions like &quot;t &amp; f | t&quot; we can read it from left to right, and chunk it up like</p>
<pre><code>t &amp; f ...
||||| ^^^ forget about what was there for now
^^^^^ we can just evaluate this leftmost &quot;t &amp; f&quot; which is f

    f ...
    f | t  which is &quot;t&quot;
    ^ replace the leftmost expression with its value, in this case f

t &amp; f | t is &quot;t&quot;
</code></pre>
<p>We didn't really need to peek-ahead or remember much more than &quot;what is the left operand&quot; (last computed value t/f) for any given step.
Fairly simple, and doesn't require much brain space.</p>
<p>To think like a <em>computer</em>: we got to be a little more precise.
If we're going character by character, we only need to remember 2 things:</p>
<pre><code>    t ... we've got 't'
  t &amp; ... an operator, so we've got 't &amp;' and expecting t/f next?
t &amp; f ... replace it with the value of &quot;t &amp; f&quot; which is &quot;f&quot;
    f ...
  f | ... there better be t or f next
f | t     there is, replace it with value of &quot;f | t&quot; which is &quot;t&quot;
</code></pre>
<p>so we have to remember the left operand and the operator if we're stepping character by character.</p>
<p>You may notice my example doesn't use the not '!' or parentheses '(',')'.
Let's restrict the grammar for a minute and just consider:</p>
<pre><code>expr ::= 't' | 'f' | expr '&amp;' expr | expr '|' expr
</code></pre>
<p>Which is pretty easy to parse and evaluate the expressions</p>
<pre><code>typedef enum Op { And, Or } Op;

bool
eval(bool l, Op op, bool r) {
	switch (op) {
	case And: return l &amp;&amp; r;
	case Or: return l || r;
	}
}

typedef enum State { S_S, S_E } State;

int
parse(bool* b) {
	bool l;
	Op op;
	int c;
	State s = S_S;

	while ((c=getchar(stdin)) != EOF &amp;&amp; c != '\n')
	switch (s) {
	case S_S: switch (c) {
		case 't': *b = eval(l, op, true); s = S_E; break;
		case 'f': *b = eval(l, op, false); s = S_E; break;
		default: err(&quot;Unexpected&quot;);
		} break;
	case S_E: switch (c) {
		case '&amp;': l = *b; op = And; s = S_S; break;
		case '|': l = *b; op = Or; s = S_S; break;
		default: err(&quot;Unexpected&quot;);
		} break;
	}

	return s == S_E;
}
</code></pre>
<p>but how should we handle not and paren nesting?
We could handle not like we handle and/or, just there's no first argument to remember.</p>
<pre><code>enum Op { Not, And, Or };
...
eval(bool l, Op op, bool r) {
...
	case Not: return !r;
...
parse(bool *b) {
...
		case '|': ...
		case '!': op = Not; s = S_S; break;
</code></pre>
<p>Now parens are tricky, consider &quot;t | (t &amp; f)&quot;
Can't just use a paren counter, because</p>
<pre><code>t | ...
^^^ okay, store Or(t) for next value
    ( ... )
      ^^^ but next value is everything in here
</code></pre>
<p>uh, what if we just par++ and keep going?</p>
<pre><code>t | t ... ez
    t ...
  t &amp; ...
t &amp; f ...
  f )     uh, par-- looks good
    f     we're done, but that's not right
</code></pre>
<p>if we don't evaluate the right-hand operand separately, then we're just ignoring the parens for evaluating, and can end up with a wrong answer.
Effectively what we did was transform &quot;t | (t &amp; f)&quot; to &quot;(t | t) &amp; f&quot; which isn't valid.</p>
<p>So, what to do?
We can't just add some more memory</p>
<pre><code>...
	bool l, l2;
	Op op, op2;
...
</code></pre>
<p>because then we can only remember 2 operations back, but what if it's &quot;t | (t | (t &amp; f))&quot;?</p>
<h2>Push Down Automata</h2>
<p>This is looking like we'll need to support some arbitrary depth of memory.
People, and computers can't do <em>arbitrary</em> memory, but we can write programs in a way that says: keep remembering until you physically cannot anymore.
For me that limit is like 3 things, but computers usually have a little more depth.</p>
<p>We're going to ask it to just keep remembering the list of operators before until it can finally evaluate them.
This combination of &quot;left operatorand and operator&quot; is &quot;pushed down&quot; onto a stack of others that may have been added before it.</p>
<p>Aside: this concept is some of that old gold of algorithms/computing referred to as a &quot;stack&quot; a &quot;list&quot; a &quot;Last-In-First-Out (LIFO) queue&quot; and even in some old papers a &quot;cellar&quot;.</p>
<p>Anyway, we're going to implement a stack of ops using a list.
A stack is more descriptive of what you can do with it (push/pop) and list is how the data looks (head + tail).
The stack behaviour is where the &quot;Push Down&quot; comes from for &quot;Push Down Automata&quot;.</p>
<pre><code>typedef enum Op { Not, And, Or } Op;
typedef struct OpList {
	Op op;
	bool l;
	OpList* next;
} OpList;

OpList*
push(OpList* os, Op op, bool l) {
	OpList* r = malloc(sizeof(OpList));
	*r = (OpList){ .op=op, .next=os };
	return r;
}

OpList
pop(OpList* os) {
	OpList r = *os;
	free(os);
	return r;
}

bool
eval(bool l, Op op, bool r) {
	switch (op) {
	case Not: return !r;
	case Or: return l || r;
	case And: return l &amp;&amp; r;
	} 
}
</code></pre>
<p>that looks good, let's write the parse function</p>
<pre><code>typedef enum State { S_S, S_E } State;

int
parse(bool* b) {
	int c;
	State s = S_S;
	OpList* os = NULL;

	while ((c=getchar(stdin)) != EOF &amp;&amp; c != '\n')
	switch (s) {
	case S_S: switch (c) {
		case 't': *b = eval(os-&gt;l, os-&gt;op, true); s = S_E; break;
		                    ^^^^^ I don't feel too good about this, we initialized it to NULL, so this is just going to throw an error
</code></pre>
<p>maybe we can make sure it's not NULL by pushing a value on there to begin with?</p>
<pre><code>	OpList* os = push(NULL, _, _)
	                        ^ but what Op should it be?
</code></pre>
<p>anything we start it out with translates expr to</p>
<pre><code>! expr   -- if we push Not
_ &amp; expr -- if we push And and some bool
_ | expr -- if we push Or and some bool
</code></pre>
<p>I think we should just add some other Op variant that's like &quot;do nothing&quot;.
Evaluating it on the line</p>
<pre><code>		case 't': *b = eval(os-&gt;l, os-&gt;op, true); s = S_E; break;
</code></pre>
<p>should result in *b = true, so I think we have enough to fill it in.</p>
<pre><code>typedef enum Op { Nop, Not, And, Or };
...
eval(...) {
...
	case Nop: return r;
...


int
parse(bool* b) {
	int c;
	State s = S_S;
	OpList* os = push(NULL, Nop, *b);

	while ((c=getchar(stdin)) != EOF &amp;&amp; c != '\n')
	switch (s) {
	case S_S: switch (c) {
		case 't': *b = eval(os-&gt;l, os-&gt;op, true); s = S_E; break;
		case 'f': *b = eval(os-&gt;l, os-&gt;op, false); s = S_E; break;
		case '!': os = push(os, Not, *b); break;
		case '(': os = push(os, Nop, *b); break;
		default: err(&quot;Unexpected&quot;);
		} break;

	case S_E: switch (c) {
		case '&amp;': os = push(os, And, *b); s = S_E; break;
		case '|': os = push(os, Or, *b); s = S_E; break;
		case ')': ;
			if (!os-&gt;next) err(&quot;Unexpected&quot;);
			OpList ol = pop(os);
			os = ol.next;

			if (ol.op != Nop) err(&quot;Unexpected&quot;);
			*b = eval(os-&gt;l, os-&gt;op, ol.l);
			break;
		} break;
	}

	if (os &amp;&amp; os-&gt;next) err(&quot;Expected more&quot;);

	pop(os);

	return s == S_E;
}
</code></pre>
<p>The case ')' line is maybe not really an obvious translation from the previous</p>
<pre><code>if (pars == 0) err(&quot;Unexpected&quot;); pars--;
</code></pre>
<p>but in that simpler case, it was checking to make sure it hadn't read more ')' than there were '(' preceding.</p>
<h2>Correction</h2>
<p>The code presented won't actually run correctly, and this is because we <em>still</em> haven't handled parens and nesting correctly.
Once an op like <code>Not</code>, <code>And</code>, or <code>Or</code> is evaluated, that op should be popped from the top of the stack.
We could change the <code>case 't'</code> line to read something like</p>
<pre><code>case 't': *b = eval(os-&gt;l, os-&gt;op, true); os = os-&gt;op != Nop ? pop(os).next : os; ...
</code></pre>
<p>but I think instead our understanding of the effects of evaluation were incomplete.</p>
<p>I had only mentioned how <code>b</code> changes under evaluation, but it looks like the value of <code>os</code> also changes depending on the op being evaluated.
Thus, let's change <code>eval</code> to reflect this</p>
<pre><code>OpList*
eval(OpList* os, bool* b) {
	switch(os-&gt;op) {
	case Nop: break;
	case Not: *b = !*b; os = pop(os).next; return os;
	case And: *b = os-&gt;l &amp;&amp; *b; os = pop(os).next; return os;
	case Or: *b = os-&gt;l &amp;&amp; *b; os = pop(os).next; return os;
	}
}
</code></pre>
<p>and its usage</p>
<pre><code>case 't': *b = true; os = eval(os, b); s = S_E; break;
case 'f': *b = false; os = eval(os, b); s = S_E; break;
...
case ')':
	if (!os-&gt;next || os-&gt;op != Nop) err(&quot;Unexpected&quot;);
	os = pop(os).next;
	os = eval(os, b);
	break;
</code></pre>
<p>The final program with all these changes (as well as some debugging additions) is available as <a href="1109-parser1_PDA/parser.c">parser.c</a>.</p>
<p>As an addendum, and because I enjoy words, what we've made here can be considered a <em>stack machine</em>, specifically a <em>pushdown machine</em> (because it does not permit arbitrary depth operations in the stack, it really just works with the head).
However, it also has a single boolean register (<code>b</code>), and so could be considered an <em>accumulator</em> which is a name used for machines with a single register.</p>
<h2>Conclusion</h2>
<p>We defined a grammar and wrote a nice little parser in C for it.
The way I decided to break it up was to build up the parsing understanding first, then build up understanding on how to evaluate the actual expression.</p>
<p>Next time, I'll write about either yacc parsers, or maybe a recursive descent version.
I may fill in this post later with some asides and more links to the theory that underpins the decisions or designs of parsers.</p>
<p>sick</p>
<p><strong>-<a href="https://isthisa.website" rel="author">JD</a></strong></p>
</div>
</body>
</html>
